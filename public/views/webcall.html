<!DOCTYPE html>
<html ng-app="app">
	<head>
  	<!-- Title -->
		<title>TalkRTC Webcall</title>

		<!-- Metas -->
    <meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no">

		<!-- Vendor stylesheets -->
		<link href="https://fonts.googleapis.com/css?family=Open+Sans|Quicksand:300,400,500,700" rel="stylesheet" />
		<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" />

		<!-- Custom stylesheets -->
    <link rel="stylesheet" type="text/css" href="/public/stylesheets/global.css" />
		<link rel="stylesheet" type="text/css" href="/public/stylesheets/webcall.css" />

		<!-- Vendor scripts -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.7.2/angular.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.7.2/angular-cookies.js"></script>
		<script src="/public/scripts/socket.io.js"></script>
	</head>
	<body ng-controller="webcall">
		<div class="webcall">
			<div class="webcall-container">
				<div class="keypad">
					<!-- Keypad infos -->
					<div class="keypad-infos">
						<div class="keypad-title">{{ keypad.title }}</div>
						<div class="keypad-secret">{{ keypad.stars }}</div>
					</div>

					<!-- Keypad numeric pad -->
					<div class="keypad-pad">
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(1)">1</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(2)">2</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(3)">3</div></div>
						</div>
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(4)">4</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(5)">5</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(6)">6</div></div>
						</div>
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(7)">7</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(8)">8</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(9)">9</div></div>
						</div>
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number">&nbsp;</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(0)">0</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.reset()">C</div></div>
						</div>
					</div>
				</div>

				<div class="call">
		      <div class="call-infos">
						<div class="infos-username"></div>
						<video id="local-video" muted="muted" width="320px" height="240px" autoplay></video>
						<video id="remote-video" width="320px" height="240px" autoplay></video>
						<div class="infos-state">{{ call.infos.state }}</div>
						<div class="infos-timer" ng-show="call.state.state === 'ongoing'">{{ call.infos.timer }}</div>
						<div class="infos-rating" ng-show="call.state.state === 'ended'">
							<span class="fa fa-fw fa-star" ng-click="callRate(1)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(2)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(3)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(4)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(5)"></span>
						</div>
					</div>
					<div class="call-actions">
						<div class="action-row" ng-show="call.state.state === 'ongoing'">
							<!-- Mute call -->
							<div class="action-item">
								<div id="call-mute" class="action-button" ng-click="callMute()">
									<span class="fa fa-fw fa-microphone"></span>
								</div>
							</div>
							<!-- Unmute call -->
							<div class="action-item hide">
								<div id="call-unmute" class="action-button" ng-click="callUnmute()">
									<span class="fa fa-fw fa-microphone-slash"></span>
								</div>
							</div>
							<!-- Settings -->
							<div class="action-item">
								<div id="call-settings" class="action-button" ng-click="callSettings()">
									<span class="fa fa-fw fa-cog"></span>
								</div>
							</div>
						</div>
						<div class="action-row" ng-show="call.state.state === 'ringing'">
							<!-- Reject call -->
							<div class="action-item">
								<div id="call-reject" class="action-button" ng-click="callReject()">
									<span class="fa fa-fw fa-times"></span>
								</div>
							</div>
							<!-- Answer call -->
							<div class="action-item">
								<div id="call-answer" class="action-button" ng-click="callAnswer()">
									<span class="fa fa-fw fa-check"></span>
								</div>
							</div>
						</div>
						<div class="action-row">
							<!-- Make call -->
							<div class="action-item" ng-show="call.state.state === 'idle'">
								<div id="call-make" class="action-button" ng-click="callMake()">
									<span class="fa fa-fw fa-phone"></span>
								</div>
							</div>
							<!-- Hangup call -->
							<div class="action-item" ng-show="call.state.state === 'calling' || call.state.state === 'connecting' || call.state.state === 'ongoing'">
								<div id="call-hangup" class="action-button" ng-click="callHangup()">
									<span class="fa fa-fw fa-phone"></span>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

		<script>
		(function() {
			var app = angular.module('app', ['ngCookies']);

			// Angular factory for socket.io defined as "socket"
		  app.factory('socket', function ($rootScope) {
		    var socket = io('https://192.168.1.26:3001/webcall');

		    return {
		      on: function (eventName, callback) {
		        socket.on(eventName, function () {
		          var args = arguments;
		          $rootScope.$apply(function () {
		            callback.apply(socket, args);
		          });
		        });
		      },
		      emit: function (eventName, data, callback) {
		        socket.emit(eventName, data, function () {
		          var args = arguments;
		          $rootScope.$apply(function () {
		            if (callback) {
		              callback.apply(socket, args);
		            }
		          });
		        })
		      }
		    };
		  });

			app.controller('webcall', function($scope, $http, $window, $location, $cookies, $interval, socket) {
				window.URL = window.URL || window.webkitURL || window.mozURL;

				/*
				** RTC object
				*/
				var rtc = {
					options: {
						iceServers: [{
							url: 'stun:stun1.l.google.com:19302'
						}],
						mediaConstraints: {
							audio: true,
							video: false
						}
					},
					localVideo: document.getElementById('local-video'),
					remoteVideo: document.getElementById('remote-video'),
					peerConnection: null
				};

				/*
				** Create a new RTCPeerConnection object and attach handlers to it
				*/
				rtc.createRTCPeerConnection = function() {
					console.log('"createRTCPeerConnection" => Creating new RTCPeerConnection object');

					/*
					** Check if peerConnection object exists
					*/
					if (rtc.peerConnection) {
						console.error('"createRTCPeerConnection" => RTCPeerConnection object already exists');
						return false;
					}

					/*
					** Create new peerConnection object
					*/
					rtc.peerConnection = new RTCPeerConnection({ iceServers: rtc.options.iceServers });
					console.info(rtc.peerConnection);

					/*
					** The local ICE layer calls your icecandidate event handler,
					** when it needs you to transmit an ICE candidate to the other peer,
					** through your signaling server.
					*/
					rtc.peerConnection.onicecandidate = rtc.handleICECandidateEvent;

					/*
					** Let you know when a remote stream has been added to your connection
					*/
					rtc.peerConnection.onaddstream = rtc.handleAddStreamEvent;

					/*
					** Let you know when the remote stream removes a stream from your connection
					*/
					rtc.peerConnection.onremovestream = rtc.handleRemoveStreamEvent;

					/*
					** Let you know about changes to the state of the ICE connection.
					** This can help you know when the connection has failed, or been lost.
					*/
					rtc.peerConnection.oniceconnectionstatechange = rtc.handleICEConnectionStateChangeEvent;

					/*
					** When the ICE agent's process of collecting candidates shifts,
					** from one state to another
					*/
					rtc.peerConnection.onicegatheringstatechange = rtc.handleICEGatheringStateChangeEvent;

					//
					rtc.peerConnection.onsignalingstatechange = rtc.handleSignalingStateChangeEvent;

					/*
					** This function is called whenever the WebRTC infrastructure needs you to
					** start the session negotiation process anew. Its job is to create and send
					** an offer, to the callee, asking it to connect with us
					*/
					rtc.peerConnection.onnegotiationneeded = rtc.handleNegotiationNeededEvent;

					return true;
				};

				/*
				** Request for local microphone and camera access and attach stream to localVideo tag
				*/
				rtc.handleGetUserMedia = function() {
					console.log('"handleGetUserMedia" => Creating a new call...');

					/*
					** Check for an existing RTCPeerConnection object or create a new one
					*/
					if (!rtc.createRTCPeerConnection()) {
						return false;
					}

					/*
					** Request access to local microphone and camera
					*/
					console.log('"handleGetUserMedia" => Getting local UserMedia...');
					navigator.mediaDevices.getUserMedia({ audio: true, video: false })
					.then(function(stream) {
						console.info(stream);

						console.log('"handleGetUserMedia" => Adding stream to local video...');
						rtc.localVideo.src = window.URL.createObjectURL(stream);
						rtc.localVideo.play();

						/*
						** We add the stream to the RTCPeerConnection
						** This stream needs adding to the connection before ICE negotiation can occur,
						** since the ICE layer will use information from the stream when negotiating the connection
						*/
						console.log('"handleGetUserMedia" => Adding tracks to RTCPeerConnection object');
						stream.getTracks().forEach(track => {
							console.info(track);
							rtc.peerConnection.addTrack(track, stream);
						});
					})
					.catch(error => {
						console.error(error);
					});
				};

				/*
				** Remove streams from local and remote video
				** Close RTCPeerConnection
				*/
				rtc.destroyRTCPeerConnection = function() {
					if (rtc.localVideo.srcObject) {
						console.log('"destroyRTCPeerConnection" => Stopping local video tracks...');
						rtc.localVideo.srcObject.getTracks().forEach(track => {
							console.info(track);
							track.stop();
						});
						rtc.localVideo.srcObject = null;
					}

					if (rtc.remoteVideo.srcObject) {
						console.log('"destroyRTCPeerConnection" => Stopping remote video tracks...');
						rtc.remoteVideo.srcObject.getTracks().forEach(track => {
							console.info(track);
							track.stop();
						});
						rtc.remoteVideo.srcObject = null;
					}

					if (rtc.peerConnection) {
						console.log('"destroyRTCPeerConnection" => Closing RTCPeerConnection...');
						rtc.peerConnection.close();
						rtc.peerConnection = null;
					}
				};

				/*
				** Once the caller has created its RTCPeerConnection, created a media stream,
				** and added it to the connection the browser will activate a negotiationneeded
				** event when it's ready for a connection with another peer
				*/
				rtc.handleNegotiationNeededEvent = function() {
					console.log('"handleNegotiationNeededEvent" => Creating local sdp description');

					rtc.peerConnection.createOffer()
					.then(function(offer) {
						console.info(offer);
						return rtc.peerConnection.setLocalDescription(offer);
					})
					.then(function() {
						console.log('"handleNegotiationNeededEvent" => Sending local sdp description');
						socket.emit('webrtc-offer', rtc.peerConnection.localDescription);
					})
					.catch(error => console.error(error));
				};

				/*
				** Sending ICE candidate to peer
				*/
				rtc.handleICECandidateEvent = function(event) {
					console.log('"handleICECandidateEvent" => Sending ICE candidate to peer...');
					console.info(event);

					if (event && event.candidate) {
						socket.emit('webrtc-ice-candidate', event.candidate);
					}
				};

				/*
				** Adding peer remote stream
				*/
				rtc.handleAddStreamEvent = function(event) {
					console.log('"handleAddStreamEvent" => Adding stream to remote video...');
					console.info(event);

					rtc.remoteVideo.srcObject = event.stream;
					rtc.remoteVideo.play();
				};

				rtc.handleRemoveStreamEvent = function(event) {
					console.log('"handleRemoveStreamEvent"');
					console.info(event);
				};

				rtc.handleICEConnectionStateChangeEvent = function(event) {
					console.log('"handleICEConnectionStateChangeEvent"');
					console.info(event);
				};

				rtc.handleICEGatheringStateChangeEvent = function(event) {
					console.log('"handleICEGatheringStateChangeEvent"');
					console.info(event);
				};

				rtc.handleSignalingStateChangeEvent = function(event) {
					console.log('"handleSignalingStateChangeEvent"');
					console.info(event);
				};

				/*
				** Receiving ICE candidate from peer
				*/
				socket.on('webrtc-ice-candidate', function(candidate) {
					console.log('"socket:webrtc-ice-candidate" => Receiving new ICE candidate from peer');
					console.info(candidate);

					rtc.peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
					.then(result => console.log(result))
					.catch(error => console.error(error));
				});

				/*
				** Receiving SDP from peer
				*/
				socket.on('webrtc-offer', function(sdp) {
					console.log('"socket:webrtc-offer" => Receiving new session description from peer');
					console.info(sdp);

					if (!rtc.createRTCPeerConnection()) {
						return ;
					}

					rtc.peerConnection.setRemoteDescription(new RTCSessionDescription(sdp))
					.then(function () {
						return navigator.mediaDevices.getUserMedia({ audio: true, video: false });
					})
					.then(function(stream) {
						rtc.localVideo.src = window.URL.createObjectURL(stream);
						rtc.localVideo.play();

						stream.getTracks().forEach(track => {
							console.log(track);
							return rtc.peerConnection.addTrack(track, stream);
						});

						return Promise.resolve();
					})
					.then(function() {
						return rtc.peerConnection.createAnswer();
					})
					.then(function(answer) {
						return rtc.peerConnection.setLocalDescription(answer);
					})
					.then(function() {
						socket.emit('webrtc-answer', rtc.peerConnection.localDescription);
					})
					.catch(error => console.error(error));
				});

				/*
				** Receiving answer
				*/
				socket.on('webrtc-answer', function(sdp) {
					console.log('"socket:webrtc-answer" => Receiving webrtc sdp answer');
					console.info(sdp);

					if (!rtc.createRTCPeerConnection()) {
						return ;
					}

					rtc.peerConnection.setRemoteDescription(new RTCSessionDescription(sdp))
					.catch(error => console.error(error));
				});

				/*
				** Keypad access code
				*/
				$scope.keypad = {
					secret: '',
					stars: '\u00A0',
					title: 'Enter your access code'
				};

				$scope.keypad.reset = function() {
					$scope.keypad.title = 'Enter your access code';
					$scope.keypad.stars = '\u00A0';
					$scope.keypad.secret = '';
				};

				$scope.keypad.click = function(num) {
					if ($scope.keypad.secret.length == 0) {
						$scope.keypad.reset();
					}
					$scope.keypad.secret += num;
					$scope.keypad.stars += '*';
					if ($scope.keypad.secret.length == 6) {
						if ($scope.keypad.secret == '094463') {
							$scope.keypad.title = 'Valid access code';
							$scope.keypad.secret = '';
						} else {
							$scope.keypad.title = 'Invalid access code';
							$scope.keypad.secret = '';
						}
					}
				};

				/*
				** Call object
				*/
				$scope.call = {};

				$scope.call.state = {};

				/*
				** Call state
				*/
				$scope.call.state.state = 'idle';

				$scope.call.state.updateState = function(state) {
					switch(state) {
						// At this point nothing going on. You can either make or recieve a call.
						case 'idle':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "idle"');
							$scope.call.infos.state = 'Click to make call';
							$scope.call.state.state = state;
							break;

						// Waiting for the user on the other end to accept the call
						case 'calling':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "calling"');
							$scope.call.infos.state = 'Calling...';
							$scope.call.state.state = 'calling';
							break;

						// The user on the other end is trying to reach us
						case 'ringing':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "ringing"');
							$scope.call.infos.state = 'Ringing...';
							$scope.call.state.state = 'ringing';
							break;

						// The Webrtc is trying to connect both ends
						case 'connecting':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "connecting"');
							$scope.call.infos.state = 'Connecting...';
							$scope.call.state.state = 'connecting';
							break;

						// The call is actually ongoing
						case 'ongoing':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "ongoing"');
							$scope.call.state.state = 'ongoing';
							break;

						// The call has ended without errors
						case 'ended':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "ended"');
							$scope.call.infos.state = 'Call ended. Please rate your call.';
							$scope.call.state.state = 'ended';
							break;

						// The call failed at some point
						case 'failed':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "failed"');
							$scope.call.infos.state = 'Call failed, try again.';
							$scope.call.state.state = 'idle';
							break;

						// The call has been rejected by the user on the other end
						case 'rejected':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "rejected"');
							$scope.call.infos.state = 'Call rejected. Try again.';
							$scope.call.state.state = 'idle';
							break;

						// Idle by default
						default:
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "idle"');
							$scope.call.infos.state = 'Click to make call';
							$scope.call.state.state = 'idle';
							break;
					}
				}

				/*
				** Call informations
				*/
				$scope.call.infos = {};
				$scope.call.infos.state = 'Click to make a call';
				$scope.call.infos.timer = '00:00:00';
				$scope.call.infos.rate = 0;

				/*
				** Call timer
				*/
				$scope.call.timer = {};

				// Counter
				$scope.call.timer.timer = 0;

				// Handle for refresh loop
				$scope.call.timer.handle = null;

				// Convert the counter to human readable format
				$scope.call.timer.convertToHMS = function(timer) {
			    var sec_num = parseInt(timer, 10);
			    var hours = Math.floor(sec_num / 3600);
			    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
			    var seconds = sec_num - (hours * 3600) - (minutes * 60);

			    if (hours < 10)
						hours = '0' + hours;
			    if (minutes < 10)
						minutes = '0' + minutes;
			    if (seconds < 10)
						seconds = '0' + seconds;
			    return hours + ':' + minutes + ':' + seconds;
				}

				// Start the refresh loop
				$scope.call.timer.start = function() {
					if ($scope.call.timer.handle) return ;
					$scope.call.timer.handle = $interval(function() {
						$scope.call.timer.timer += 1;
						$scope.call.infos.timer = $scope.call.timer.convertToHMS($scope.call.timer.timer);
					}, 1000);
				};

				// Stop the refresh loop
				$scope.call.timer.stop = function() {
					if (!$scope.call.timer.handle) return ;
					$interval.cancel($scope.call.timer.handle);
					$scope.call.timer.handle = null;
					$scope.call.timer.timer = 0;
					$scope.call.infos.timer = '00:00:00';
				};

				/*
				** Call actions
				*/

				// Rate call
				$scope.callRate = function(rate) {
					console.log('[ ACTION ] Rating call (' + rate + ')');
					$scope.call.infos.rate = rate;
					$scope.call.state.updateState('idle');
				};

				// Send a call invitation
				$scope.callMake = function() {
					console.log('[ ACTION ] Making call...');
					$scope.call.state.updateState('calling');
					socket.emit('call-invite');
				};

				// Hangup call
				$scope.callHangup = function() {
					console.log('[ ACTION ] Hanging up call...');
					$scope.call.state.updateState('ended');
					socket.emit('call-hangup');
					rtc.destroyRTCPeerConnection();
				};

				// Mute call
				$scope.callMute = function() {
					console.log('[ ACTION ] Muting call...');
					$scope.call.state.updateState('ended');
				};

				// Unmute call
				$scope.callUnmute = function() {
					console.log('[ ACTION ] Unmuting call...');
				};

				// Setting for call
				$scope.callSettings = function() {
					console.log('[ ACTION ] Call settings...');
				};

				// Answer call
				$scope.callAnswer = function() {
					console.log('[ ACTION ] Answering call...');
					$scope.call.state.updateState('connecting');
					socket.emit('call-answer');
					rtc.handleGetUserMedia();
				};

				// Reject call
				$scope.callReject = function() {
					console.log('[ ACTION ] Rejecting call...');
					$scope.call.state.updateState('idle');
					socket.emit('call-reject');
					rtc.destroyRTCPeerConnection();
				};

				/*
				** Incoming messages from socket
				*/

				// Call is incoming
				socket.on('call-invite', function() {
					$scope.call.state.updateState('ringing');
				});

				// Call has been answered
				socket.on('call-answer', function() {
					$scope.call.state.updateState('connecting');
				});

				// Call has been rejected
				socket.on('call-reject', function() {
					$scope.call.state.updateState('rejected');
					rtc.destroyRTCPeerConnection();
				});

				// Call has been hanged up
				socket.on('call-hangup', function() {
					$scope.call.state.updateState('ended');
					rtc.destroyRTCPeerConnection();
				});
			});
		})();
		</script>
	</body>
</html>
