<!DOCTYPE html>
<html ng-app="app">
	<head>
  	<!-- Title -->
		<title>TalkRTC Webcall</title>

		<!-- Metas -->
    <meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no">

		<!-- Vendor stylesheets -->
		<link href="https://fonts.googleapis.com/css?family=Open+Sans|Quicksand:300,400,500,700" rel="stylesheet" />
		<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" />

		<!-- Custom stylesheets -->
    <link rel="stylesheet" type="text/css" href="/public/stylesheets/global.css" />
		<link rel="stylesheet" type="text/css" href="/public/stylesheets/webcall.css" />

		<!-- Vendor scripts -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.7.2/angular.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.7.2/angular-cookies.js"></script>
		<script src="/public/scripts/socket.io.js"></script>
	</head>
	<body ng-controller="webcall">
		<div class="webcall">
			<div class="webcall-container">
				<div class="keypad">
					<!-- Keypad infos -->
					<div class="keypad-infos">
						<div class="keypad-title">{{ keypad.title }}</div>
						<div class="keypad-secret">{{ keypad.stars }}</div>
					</div>

					<!-- Keypad numeric pad -->
					<div class="keypad-pad">
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(1)">1</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(2)">2</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(3)">3</div></div>
						</div>
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(4)">4</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(5)">5</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(6)">6</div></div>
						</div>
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(7)">7</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(8)">8</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(9)">9</div></div>
						</div>
						<div class="keypad-row">
							<div class="keypad-item"><div class="keypad-number">&nbsp;</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.click(0)">0</div></div>
							<div class="keypad-item"><div class="keypad-number" ng-click="keypad.reset()">C</div></div>
						</div>
					</div>
				</div>

				<div class="call">
		      <div class="call-infos">
						<div class="infos-username"></div>
						<video id="local-video" muted="muted" width="320px" height="240px" style="display: none;"></video>
						<video id="remote-video" width="320px" height="240px" style="display: none;"></video>
						<div class="infos-state" ng-hide="call.state.state === 'ongoing'">{{ call.infos.state }}</div>
						<div class="infos-timer" ng-show="call.state.state === 'ongoing'">{{ call.infos.timer }}</div>
						<div class="infos-rating" ng-show="call.state.state === 'ended'">
							<span class="fa fa-fw fa-star" ng-click="callRate(1)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(2)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(3)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(4)"></span>
							<span class="fa fa-fw fa-star" ng-click="callRate(5)"></span>
						</div>
					</div>
					<div class="call-actions">
						<div class="action-row" ng-show="call.state.state === 'ongoing'">
							<!-- Mute call -->
							<div class="action-item">
								<div id="call-mute" class="action-button" ng-click="callMute()">
									<span class="fa fa-fw fa-microphone"></span>
								</div>
							</div>
							<!-- Unmute call -->
							<div class="action-item hide">
								<div id="call-unmute" class="action-button" ng-click="callUnmute()">
									<span class="fa fa-fw fa-microphone-slash"></span>
								</div>
							</div>
							<!-- Settings -->
							<div class="action-item">
								<div id="call-settings" class="action-button" ng-click="callSettings()">
									<span class="fa fa-fw fa-cog"></span>
								</div>
							</div>
						</div>
						<div class="action-row" ng-show="call.state.state === 'ringing'">
							<!-- Reject call -->
							<div class="action-item">
								<div id="call-reject" class="action-button" ng-click="callReject()">
									<span class="fa fa-fw fa-times"></span>
								</div>
							</div>
							<!-- Answer call -->
							<div class="action-item">
								<div id="call-answer" class="action-button" ng-click="callAnswer()">
									<span class="fa fa-fw fa-check"></span>
								</div>
							</div>
						</div>
						<div class="action-row">
							<!-- Make call -->
							<div class="action-item" ng-show="call.state.state === 'idle'">
								<div id="call-make" class="action-button" ng-click="callMake()">
									<span class="fa fa-fw fa-phone"></span>
								</div>
							</div>
							<!-- Hangup call -->
							<div class="action-item" ng-show="call.state.state === 'calling' || call.state.state === 'connecting' || call.state.state === 'ongoing'">
								<div id="call-hangup" class="action-button" ng-click="callHangup()">
									<span class="fa fa-fw fa-phone"></span>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

		<script>
		(function() {
			var app = angular.module('app', ['ngCookies']);

			// Angular factory for socket.io defined as "socket"
		  app.factory('socket', function ($rootScope) {
		    var socket = io('https://192.168.1.26:3001/webcall');

		    return {
		      on: function (eventName, callback) {
		        socket.on(eventName, function () {
		          var args = arguments;
		          $rootScope.$apply(function () {
		            callback.apply(socket, args);
		          });
		        });
		      },
		      emit: function (eventName, data, callback) {
		        socket.emit(eventName, data, function () {
		          var args = arguments;
		          $rootScope.$apply(function () {
		            if (callback) {
		              callback.apply(socket, args);
		            }
		          });
		        })
		      }
		    };
		  });

			app.controller('webcall', function($scope, $http, $window, $location, $cookies, $interval, socket) {
				window.URL = window.URL || window.webkitURL || window.mozURL;

				var pc = null;
				var localVideo = document.getElementById('local-video');
				var remoteVideo = document.getElementById('remote-video');
				var iceServers = [{ url: 'stun:stun1.l.google.com:19302' }];
				var mediaConstraints = { audio: true, video: false };
				var ringtone = new Audio('/public/sounds/ringtone.mp3');

				function createRTCPeerConnection(role = 'caller') {
					console.log('[ WEBRTC ] Creating new RTCPeerConnection object');

					if (pc) {
						console.error('[ WEBRTC ] RTCPeerConnection object already exists');
						return false;
					}

					pc = new RTCPeerConnection({ iceServers: iceServers });

					pc.onicecandidate = handleICECandidateEvent;
					pc.onaddstream = handleAddStreamEvent;
					pc.onremovestream = handleRemoveStreamEvent;
					pc.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
					pc.onicegatheringstatechange = handleICEGatheringStateChangeEvent;
					pc.onsignalingstatechange = handleSignalingStateChangeEvent;
					pc.onnegotiationneeded = (role == 'caller') ? handleNegotiationNeededEvent : null;

					return true;
				};

				function handleGetUserMedia() {
					console.log('[ WEBRTC ] Accessing microphone and camera');

					navigator.mediaDevices.getUserMedia(mediaConstraints)
					.then(function(stream) {
						console.log('[ WEBRTC ] Adding stream to local video');
						if ('srcObject' in localVideo) {
					    localVideo.srcObject = stream;
					  } else {
					    localVideo.src = window.URL.createObjectURL(stream);
					  }
					  localVideo.onloadedmetadata = function(e) {
					    localVideo.play();
					  };

						console.log('[ WEBRTC ] Adding tracks/stream to peer connection');
						stream.getTracks().forEach(track => pc.addTrack(track, stream));
					})
					.catch(error => console.error(error));
				};

				function destroyRTCPeerConnection() {
					console.log('localVideo', localVideo.srcObject);
					console.log('remoteVideo', remoteVideo.srcObject);
					console.log(pc);
					if (localVideo.srcObject) {
						console.log('[ WEBRTC ] Stopping local tracks');
						localVideo.srcObject.getTracks().forEach(track => track.stop());
						localVideo.srcObject = null;
					}

					if (remoteVideo.srcObject) {
						console.log('[ WEBRTC ] Stopping remote tracks');
						remoteVideo.srcObject.getTracks().forEach(track => track.stop());
						remoteVideo.srcObject = null;
					}

					if (pc) {
						console.log('[ WEBRTC ] Closing peer connection');
						pc.close();
						pc = null;
					}
				};

				function handleNegotiationNeededEvent() {
					console.log('[ WEBRTC ] Creating offer');
					pc.createOffer()
					.then(function(offer) {
						console.log('[ WEBRTC ] Saving local session description');
						return pc.setLocalDescription(offer);
					})
					.then(function() {
						console.log('[ WEBRTC ] Sending offer');
						socket.emit('webrtc-offer', pc.localDescription);
					})
					.catch(error => console.error(error));
				};

				function handleICECandidateEvent(event) {
					console.log('[ WEBRTC ] Sending ICE candidate');
					if (event.candidate) {
						socket.emit('webrtc-ice-candidate', event.candidate);
					}
				};

				function handleAddStreamEvent(event) {
					console.log('[ WEBRTC ] Adding stream to remote video...');
					if ('srcObject' in remoteVideo) {
				    remoteVideo.srcObject = event.stream;
				  } else {
				    remoteVideo.src = window.URL.createObjectURL(event.stream);
				  }
				  remoteVideo.onloadedmetadata = function(e) {
				    remoteVideo.play();
				  };
				};

				function handleRemoveStreamEvent(event) {
					console.info(event);
				};

				// Describes the current state of the ICE agent and its connection to
				// the ICE server (STUN or TURN)
				function handleICEConnectionStateChangeEvent(event) {
					console.info(event);

					switch (event.currentTarget.iceConnectionState) {
						// The ICE agent is gathering addresses
						case "new":
							break;

						// The ICE agent is checking pairs of local and remote candidates
						// Gathering of candidates may still be underway
						case "checking":
							break;

						// A usable pairing of local and remote candidates has been found.
						// Gathering of candidates may still be underway to find a better connection option
						case "connected":
							break;

						// The ICE agent has finished gathering candidates
						case "completed":
							$scope.call.state.updateState('ongoing');
							break;

						// The ICE agent has failed to find compatible matches
						case "failed":
							$scope.call.state.updateState('ended');
							destroyRTCPeerConnection();
							break;

						// Checks to ensure that components are still connected.
						// May trigger intermittently and resolve just as spontaneously or during temporary disconnections.
						// When the problem resolves, the connection may return to the "connected" state.
						case "disconnected":
							$scope.call.state.updateState('ended');
							destroyRTCPeerConnection();
							break;

						// The ICE agent has shut down and is no longer handling requests
						case "closed":
							$scope.call.state.updateState('ended');
							destroyRTCPeerConnection();
							break;
					}
				};

				function handleICEGatheringStateChangeEvent(event) {
					console.info(event);
				};

				/*
				** Indicates where in the process of signaling the exchange of offer
				** and answer the connection currently is.
				*/
				function handleSignalingStateChangeEvent(event) {
					console.info(event);
					/*
					"stable"
						1. No ongoing exchange of offer and answer underway.
								- RTCPeerConnection object is new
								- localDescription is null
								- remoteDescription is null
						2. Negotiation is complete and a connection has been established.

					"have-local-offer"
						The local peer has called RTCPeerConnection.setLocalDescription(),
						passing in SDP representing an offer (usually created by calling
						RTCPeerConnection.createOffer()), and the offer has been applied
						successfully.

					"have-remote-offer"
						The remote peer has created an offer and used the signaling server
						to deliver it to the local peer, which has set the offer as the
						remote description by calling
						RTCPeerConnection.setRemoteDescription().

					"have-local-pranswer"
						The offer sent by the remote peer has been applied and an answer
						has been created (usually by calling
						RTCPeerConnection.createAnswer()) and applied by calling
						RTCPeerConnection.setLocalDescription().
						This provisional answer describes the supported media formats
						and so forth, but may not have a complete set of ICE candidates
						included. Further candidates will be delivered separately later.

					"have-remote-pranswer"
						A provisional answer has been received and successfully applied in
						response to an offer previously sent and established by calling
						setLocalDescription().

					"closed"
						The connection is closed.
					*/
				};

				socket.on('webrtc-ice-candidate', function(candidate) {
					console.log('[ WEBRTC ] Receiving ICE candidate.');
					pc.addIceCandidate(new RTCIceCandidate(candidate))
					.catch(error => console.error(error));
				});

				// When we receive an offer
				socket.on('webrtc-offer', function(sdp) {
					console.log('[ WEBRTC ] Receiving offer');

					// Create a new RTCPeerConnection
					createRTCPeerConnection('callee');

					// Save the peer SDP
					console.log('[ WEBRTC ] Saving remote session description');
					pc.setRemoteDescription(new RTCSessionDescription(sdp))
					// Access microphone and camera devices settings
					.then(function () {
						console.log('[ WEBRTC ] Getting access to mic and cam');
						return navigator.mediaDevices.getUserMedia(mediaConstraints);
					})
					// Setup stream and tracks
					.then(function(stream) {
						console.log('[ WEBRTC ] Saving stream');
						if ('srcObject' in localVideo) {
					    localVideo.srcObject = stream;
					  } else {
					    localVideo.src = window.URL.createObjectURL(stream);
					  }
					  localVideo.onloadedmetadata = function(e) {
					    localVideo.play();
					  };

						console.log('[ WEBRTC ] Saving tracks');
						stream.getTracks().forEach(track => pc.addTrack(track, stream));

						return Promise.resolve();
					})
					// Create an anwser
					.then(function() {
						console.log('[ WEBRTC ] Creating answer');
						return pc.createAnswer();
					})
					// Save our local SDP
					.then(function(answer) {
						console.log('[ WEBRTC ] Saving local session description');
						return pc.setLocalDescription(answer);
					})
					// Send it over to peer
					.then(function() {
						console.log('[ WEBRTC ] Sending local session description');
						socket.emit('webrtc-answer', pc.localDescription);
					})
					.catch(error => console.error(error));
				});

				//
				socket.on('webrtc-answer', function(sdp) {
					console.log('Receiving answer');
					console.log('[ WEBRTC ] Saving remote session description');
					pc.setRemoteDescription(new RTCSessionDescription(sdp))
					.catch(error => console.error(error));
				});

				/*
				** Keypad access code
				*/
				$scope.keypad = {
					secret: '',
					stars: '\u00A0',
					title: 'Enter your access code'
				};

				$scope.keypad.reset = function() {
					$scope.keypad.title = 'Enter your access code';
					$scope.keypad.stars = '\u00A0';
					$scope.keypad.secret = '';
				};

				$scope.keypad.click = function(num) {
					if ($scope.keypad.secret.length == 0) {
						$scope.keypad.reset();
					}
					$scope.keypad.secret += num;
					$scope.keypad.stars += '*';
					if ($scope.keypad.secret.length == 6) {
						if ($scope.keypad.secret == '094463') {
							$scope.keypad.title = 'Valid access code';
							$scope.keypad.secret = '';
						} else {
							$scope.keypad.title = 'Invalid access code';
							$scope.keypad.secret = '';
						}
					}
				};

				/*
				** Call object
				*/
				$scope.call = {};

				$scope.call.state = {};

				/*
				** Call state
				*/
				$scope.call.state.state = 'idle';

				$scope.call.state.updateState = function(state) {
					switch(state) {
						// At this point nothing going on. You can either make or recieve a call.
						case 'idle':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "idle"');
							$scope.call.infos.state = 'Click to make call';
							$scope.call.state.state = state;

							ringtone.pause();
							ringtone.currentTime = 0;
							break;

						// Waiting for the user on the other end to accept the call
						case 'calling':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "calling"');
							$scope.call.infos.state = 'Calling...';
							$scope.call.state.state = 'calling';
							break;

						// The user on the other end is trying to reach us
						case 'ringing':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "ringing"');
							$scope.call.infos.state = 'Ringing...';
							$scope.call.state.state = 'ringing';
							ringtone.play();
							this.currentTime = 0;
							ringtone.addEventListener('ended', function() {
								this.currentTime = 0;
								this.play();
							}, false);
							break;

						// The Webrtc is trying to connect both ends
						case 'connecting':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "connecting"');
							$scope.call.infos.state = 'Connecting...';
							$scope.call.state.state = 'connecting';
							ringtone.pause();
							break;

						// The call is actually ongoing
						case 'ongoing':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "ongoing"');
							$scope.call.state.state = 'ongoing';
							$scope.call.timer.start();
							break;

						// The call has ended without errors
						case 'ended':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "ended"');
							$scope.call.infos.state = 'Call ended. Click to make another call.';
							// $scope.call.infos.state = 'Call ended. Please rate your call.';
							// $scope.call.state.state = 'ended';
							$scope.call.state.state = 'idle';
							$scope.call.timer.stop();

							ringtone.pause();
							ringtone.currentTime = 0;
							break;

						// The call failed at some point
						case 'failed':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "failed"');
							$scope.call.infos.state = 'Call failed, try again.';
							$scope.call.state.state = 'idle';
							$scope.call.timer.stop();

							ringtone.pause();
							ringtone.currentTime = 0;
							break;

						// The call has been rejected by the user on the other end
						case 'rejected':
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "rejected"');
							$scope.call.infos.state = 'Call rejected. Try again.';
							$scope.call.state.state = 'idle';

							ringtone.pause();
							ringtone.currentTime = 0;
							break;

						// Idle by default
						default:
							console.log('[ STATE ] Call state changed from "' + $scope.call.state.state + '" to "idle"');
							$scope.call.infos.state = 'Click to make call';
							$scope.call.state.state = 'idle';

							ringtone.pause();
							ringtone.currentTime = 0;
							break;
					}
				}

				/*
				** Call informations
				*/
				$scope.call.infos = {};
				$scope.call.infos.state = 'Click to make a call';
				$scope.call.infos.timer = '00:00:00';
				$scope.call.infos.rate = 0;

				/*
				** Call timer
				*/
				$scope.call.timer = {};

				// Counter
				$scope.call.timer.timer = 0;

				// Handle for refresh loop
				$scope.call.timer.handle = null;

				// Convert the counter to human readable format
				$scope.call.timer.convertToHMS = function(timer) {
			    var sec_num = parseInt(timer, 10);
			    var hours = Math.floor(sec_num / 3600);
			    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
			    var seconds = sec_num - (hours * 3600) - (minutes * 60);

			    if (hours < 10)
						hours = '0' + hours;
			    if (minutes < 10)
						minutes = '0' + minutes;
			    if (seconds < 10)
						seconds = '0' + seconds;
			    return hours + ':' + minutes + ':' + seconds;
				}

				// Start the refresh loop
				$scope.call.timer.start = function() {
					if ($scope.call.timer.handle) return ;
					$scope.call.timer.handle = $interval(function() {
						$scope.call.timer.timer += 1;
						$scope.call.infos.timer = $scope.call.timer.convertToHMS($scope.call.timer.timer);
					}, 1000);
				};

				// Stop the refresh loop
				$scope.call.timer.stop = function() {
					if (!$scope.call.timer.handle) return ;
					$interval.cancel($scope.call.timer.handle);
					$scope.call.timer.handle = null;
					$scope.call.timer.timer = 0;
					$scope.call.infos.timer = '00:00:00';
				};

				/*
				** Call actions
				*/

				// Rate call
				$scope.callRate = function(rate) {
					console.log('[ ACTION ] Rating call (' + rate + ')');
					$scope.call.infos.rate = rate;
					$scope.call.state.updateState('idle');
				};

				// Send a call invitation
				$scope.callMake = function() {
					console.log('[ ACTION ] Making call...');
					$scope.call.state.updateState('calling');
					socket.emit('call-invite');
				};

				// Hangup call
				$scope.callHangup = function() {
					console.log('[ ACTION ] Hanging up call...');
					$scope.call.state.updateState('ended');
					socket.emit('call-hangup');
					destroyRTCPeerConnection();
				};

				// Mute call
				$scope.callMute = function() {
					console.log('[ ACTION ] Muting call...');
				};

				// Unmute call
				$scope.callUnmute = function() {
					console.log('[ ACTION ] Unmuting call...');
				};

				// Setting for call
				$scope.callSettings = function() {
					console.log('[ ACTION ] Call settings...');
				};

				// Answer call
				$scope.callAnswer = function() {
					console.log('[ ACTION ] Answering call...');
					$scope.call.state.updateState('connecting');
					socket.emit('call-answer');
				};

				// Reject call
				$scope.callReject = function() {
					console.log('[ ACTION ] Rejecting call...');
					$scope.call.state.updateState('idle');
					socket.emit('call-reject');
					destroyRTCPeerConnection();
				};

				/*
				** Incoming messages from socket
				*/

				// Call is incoming
				socket.on('call-invite', function() {
					$scope.call.state.updateState('ringing');
				});

				// Call has been answered
				socket.on('call-answer', function() {
					console.log('[ SOCKET ] Call has been anwered');
					$scope.call.state.updateState('connecting');

					createRTCPeerConnection();
					handleGetUserMedia();
				});

				// Call has been rejected
				socket.on('call-reject', function() {
					$scope.call.state.updateState('rejected');
					console.log('[ SOCKET ] Call has been rejected');
					destroyRTCPeerConnection();
				});

				// Call has been hanged up
				socket.on('call-hangup', function() {
					$scope.call.state.updateState('ended');
					console.log('[ SOCKET ] Call has been hung up');
					destroyRTCPeerConnection();
				});
			});
		})();
		</script>
	</body>
</html>
